/*
 * generated by Xtext 2.23.0
 */
package org.tvtower.ui.outline;

import java.util.ArrayList;
import java.util.List;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.ui.editor.outline.IOutlineNode;
import org.eclipse.xtext.ui.editor.outline.impl.DefaultOutlineTreeProvider;
import org.eclipse.xtext.ui.editor.outline.impl.DocumentRootNode;
import org.tvtower.bmx.Annotation;
import org.tvtower.bmx.BmxFile;
import org.tvtower.bmx.BmxFunction;
import org.tvtower.bmx.BmxMethod;
import org.tvtower.bmx.ConstantDefinition;
import org.tvtower.bmx.FieldDefinition;
import org.tvtower.bmx.FrameworkStatement;
import org.tvtower.bmx.FunctionDeclaration;
import org.tvtower.bmx.GlobalDefinion;
import org.tvtower.bmx.ImportStatement;
import org.tvtower.bmx.LocalDefinition;
import org.tvtower.bmx.Modifier;
import org.tvtower.bmx.TypeDef;
import org.tvtower.bmx.TypeLikeBlock;

/**
 * Customization of the default outline structure.
 *
 * See
 * https://www.eclipse.org/Xtext/documentation/310_eclipse_support.html#outline
 */
public class BmxOutlineTreeProvider extends DefaultOutlineTreeProvider {

	//no root node for file, no nodes for outline
	protected void _createChildren(DocumentRootNode parentNode, BmxFile model) {
		if (model.getStatements() != null && !model.getStatements().getMain().isEmpty()) {
			for (EObject element : model.getStatements().getMain()) {
				boolean show=true;
				if(element instanceof FrameworkStatement) {
					show=false;
				}else if(element instanceof ImportStatement) {
					show=false;
				}else if(element instanceof Modifier) {
					show=false;
				}
				if (show) {
					createNode(parentNode, element);
				}
			}
		}
	}

	//artificial parent for type members if there are more than 2
	protected void _createChildren(IOutlineNode parentNode, TypeLikeBlock type) {
		List<EObject> members = new ArrayList<>();
		final List<EObject> methodsEtc = new ArrayList<>();
		final List<EObject> all = new ArrayList<>();
		type.eContents().forEach(c -> {
			// I tried using a common Supertype, but for some reason the commen types field
			// was not extracted to the interface
			if (c instanceof LocalDefinition) {
				members.add(c);
				all.add(c);
			} else if (c instanceof GlobalDefinion) {
				members.add(((GlobalDefinion) c).getType());
				all.add(((GlobalDefinion) c).getType());
			} else if (c instanceof FieldDefinition) {
				members.addAll(((FieldDefinition) c).getTypes());
				all.addAll(((FieldDefinition) c).getTypes());
			} else if (c instanceof ConstantDefinition) {
				members.add(((ConstantDefinition) c).getType());
				all.add(((ConstantDefinition) c).getType());
			} else {
				methodsEtc.add(c);
				all.add(c);
			}
		});
		if (members.size() > 2 && !methodsEtc.isEmpty()) {
			IOutlineNode memberParent = createEObjectNode(parentNode, type, labelProvider.getImage("members"),
					"members", false);
			for (EObject c : members) {
				createNode(memberParent, c);
			}
			for (EObject c : methodsEtc) {
				createNode(parentNode, c);
			}
		} else {
			for (EObject c : all) {
				createNode(parentNode, c);
			}
		}
	}

	//do not create annotation node
	protected void _createNode(IOutlineNode parentObject, Annotation annotation) {}
	
	//restrict descendants 
	protected boolean _isLeaf(FieldDefinition obj) {
		return true;
	}

	protected boolean _isLeaf(TypeDef obj) {
		return true;
	}

	protected boolean _isLeaf(GlobalDefinion obj) {
		return true;
	}

	protected boolean _isLeaf(ConstantDefinition obj) {
		return true;
	}

	protected boolean _isLeaf(BmxMethod obj) {
		return true;
	}

	protected boolean _isLeaf(BmxFunction obj) {
		return true;
	}

	protected boolean _isLeaf(FunctionDeclaration obj) {
		return true;
	}
}
